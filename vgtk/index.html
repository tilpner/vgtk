<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `vgtk` crate."><meta name="keywords" content="rust, rustlang, rust-lang, vgtk"><title>vgtk - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../vgtk/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate vgtk</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all vgtk's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'vgtk', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/vgtk/lib.rs.html#1-920' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>vgtk</a></span></h1><div class='docblock'><p>A declarative UI framework built on <a href="https://www.gtk.org/">GTK</a> and <a href="https://gtk-rs.org/">Gtk-rs</a>.</p>
<h2 id="overview" class="section-header"><a href="#overview">Overview</a></h2>
<p><code>vgtk</code> is a GUI framework built on <a href="https://www.gtk.org/">GTK</a> using what might be
called the &quot;Model-View-Update&quot; pattern, as popularised in <a href="https://elm-lang.org/">Elm</a>
and <a href="https://redux.js.org/">Redux</a>, in addition to a component model similar to <a href="https://reactjs.org/">React</a>.
Its primary inspiration is the <a href="https://yew.rs/">Yew</a> web framework for Rust, from
which it inherits most of its more specific ideas.</p>
<p>To facilitate writing GTK UIs in a declarative style, <code>vgtk</code> implements
an algorithm similar to DOM diffing, but for GTK's widget tree, which
has turned out to be considerably less trivial than diffing a well structured
tree like the DOM, but as a first draft at least it gets the job done.</p>
<p>More importantly, <code>vgtk</code> also provides the <a href="macro.gtk.html"><code>gtk!</code></a> macro
allowing you to write your declarative UI in a syntax very similar to <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>.</p>
<h2 id="show-me" class="section-header"><a href="#show-me">Show Me!</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">vgtk</span>::{<span class="ident">ext</span>::<span class="kw-2">*</span>, <span class="ident">gtk</span>, <span class="ident">run</span>, <span class="ident">Component</span>, <span class="ident">UpdateAction</span>, <span class="ident">VNode</span>};
<span class="kw">use</span> <span class="ident">vgtk</span>::<span class="ident">lib</span>::{<span class="ident">gtk</span>::<span class="kw-2">*</span>, <span class="ident">gio</span>::<span class="ident">ApplicationFlags</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Default</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Model</span> {
     <span class="ident">counter</span>: <span class="ident">usize</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">Message</span> {
    <span class="ident">Inc</span>,
    <span class="ident">Exit</span>,
}

<span class="kw">impl</span> <span class="ident">Component</span> <span class="kw">for</span> <span class="ident">Model</span> {
    <span class="kw">type</span> <span class="ident">Message</span> <span class="op">=</span> <span class="ident">Message</span>;
    <span class="kw">type</span> <span class="ident">Properties</span> <span class="op">=</span> ();

    <span class="kw">fn</span> <span class="ident">update</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">message</span>: <span class="ident">Message</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">UpdateAction</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="ident">message</span> {
            <span class="ident">Message</span>::<span class="ident">Inc</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="self">self</span>.<span class="ident">counter</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
                <span class="ident">UpdateAction</span>::<span class="ident">Render</span>
            }
            <span class="ident">Message</span>::<span class="ident">Exit</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="ident">vgtk</span>::<span class="ident">quit</span>();
                <span class="ident">UpdateAction</span>::<span class="prelude-val">None</span>
            }
        }
    }

    <span class="kw">fn</span> <span class="ident">view</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">VNode</span><span class="op">&lt;</span><span class="ident">Model</span><span class="op">&gt;</span> {
        <span class="macro">gtk</span><span class="macro">!</span> {
            <span class="op">&lt;</span><span class="ident">Application</span>::<span class="ident">new_unwrap</span>(<span class="prelude-val">None</span>, <span class="ident">ApplicationFlags</span>::<span class="ident">empty</span>())<span class="op">&gt;</span>
                <span class="op">&lt;</span><span class="ident">Window</span> <span class="ident">border_width</span><span class="op">=</span><span class="number">20</span> <span class="ident">on</span> <span class="ident">destroy</span><span class="op">=</span><span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">Message</span>::<span class="ident">Exit</span><span class="op">&gt;</span>
                    <span class="op">&lt;</span><span class="ident">HeaderBar</span> <span class="ident">title</span><span class="op">=</span><span class="string">&quot;inc!&quot;</span> <span class="ident">show_close_button</span><span class="op">=</span><span class="bool-val">true</span> <span class="op">/</span><span class="op">&gt;</span>
                    <span class="op">&lt;</span><span class="ident">Box</span> <span class="ident">spacing</span><span class="op">=</span><span class="number">10</span> <span class="ident">halign</span><span class="op">=</span><span class="ident">Align</span>::<span class="ident">Center</span><span class="op">&gt;</span>
                        <span class="op">&lt;</span><span class="ident">Label</span> <span class="ident">label</span><span class="op">=</span><span class="self">self</span>.<span class="ident">counter</span>.<span class="ident">to_string</span>() <span class="op">/</span><span class="op">&gt;</span>
                        <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;inc!&quot;</span> <span class="ident">image</span><span class="op">=</span><span class="string">&quot;add&quot;</span> <span class="ident">always_show_image</span><span class="op">=</span><span class="bool-val">true</span>
                                <span class="ident">on</span> <span class="ident">clicked</span><span class="op">=</span><span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">Message</span>::<span class="ident">Inc</span> <span class="op">/</span><span class="op">&gt;</span>
                    <span class="op">&lt;</span><span class="op">/</span><span class="ident">Box</span><span class="op">&gt;</span>
                <span class="op">&lt;</span><span class="op">/</span><span class="ident">Window</span><span class="op">&gt;</span>
            <span class="op">&lt;</span><span class="op">/</span><span class="ident">Application</span><span class="op">&gt;</span>
        }
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">std</span>::<span class="ident">process</span>::<span class="ident">exit</span>(<span class="ident">run</span>::<span class="op">&lt;</span><span class="ident">Model</span><span class="op">&gt;</span>());
}</pre></div>
<h2 id="prerequisites" class="section-header"><a href="#prerequisites">Prerequisites</a></h2>
<p>The <code>vgtk</code> documentation assumes you already have a passing familiarity with <a href="https://www.gtk.org/">GTK</a> and
its <a href="https://gtk-rs.org/">Rust bindings</a>. It makes little to no effort to explain how <a href="https://www.gtk.org/">GTK</a> works or
to catalogue which widgets are available. Please refer to the <a href="https://gtk-rs.org/">Gtk-rs</a> documentation or
that of <a href="https://www.gtk.org/">GTK</a> proper for this.</p>
<h2 id="the-component-model" class="section-header"><a href="#the-component-model">The Component Model</a></h2>
<p>The core idea of <code>vgtk</code> is the <a href="trait.Component.html"><code>Component</code></a>. A component, in practical terms, is a
composable tree of Gtk widgets, often a window, reflecting a block of application state. You
can write your application as a single component, but you can also embed a component inside
another component, which makes sense for parts of your UI you tend to repeat, or just for
making an easier to use interface for a common Gtk widget type.</p>
<p>Your application starts with a component that manages an <a href="../gtk/struct.Application.html"><code>Application</code></a> object.
This <a href="../gtk/struct.Application.html"><code>Application</code></a> in turn will have one or more <a href="../gtk/struct.Window.html"><code>Window</code></a>s attached
to it, either directly inside the component or as subcomponents. <a href="../gtk/struct.Window.html"><code>Window</code></a>s in turn
contain widget trees.</p>
<p>You can think of a component as an MVC system, if that's something you're familiar with: it
contains some application state (the Model), a method for rendering that state into a tree of
GTK widgets (the View) and a method for updating that state based on external inputs like
user interaction (the Controller). You can also think of it as mapping almost directly to a
<a href="https://reactjs.org/">React</a> component, if you're more familiar with that, even down to the way it interacts with
the <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a> syntax.</p>
<h2 id="building-a-component" class="section-header"><a href="#building-a-component">Building A Component</a></h2>
<p>A component in <code>vgtk</code> is something which implements the <a href="trait.Component.html"><code>Component</code></a> trait,
providing the two crucial methods <a href="trait.Component.html#tymethod.view"><code>view</code></a> and <a href="trait.Component.html#method.update"><code>update</code></a>.
Your top level component should have a <a href="trait.Component.html#tymethod.view"><code>view</code></a> function which returns
a GTK <a href="../gtk/struct.Application.html"><code>Application</code></a> object, or, rather, a &quot;virtual DOM&quot; tree which builds one.</p>
<p>The <a href="trait.Component.html#tymethod.view"><code>view</code></a> function's job is to examine the current state of the component
(usually contained within the type of the <a href="trait.Component.html"><code>Component</code></a> itself) and return a UI tree
which reflects it. This is its only job, and however much you might be tempted to, it must not do
anything else, especially anything that might block the thread or cause a delayed result.</p>
<p>Responding to user interaction, or other external inputs, is the job of the
<a href="trait.Component.html#method.update"><code>update</code></a> function. This takes an argument of the type
<a href="trait.Component.html#associatedtype.Message"><code>Component::Message</code></a> and updates the component's state according to the
contents of the message. This is the only place you're allowed to modify the contents of your
component, and every way to change it should be expressed as a message you can send to
your <a href="trait.Component.html#method.update"><code>update</code></a> function.</p>
<p><a href="trait.Component.html#method.update"><code>update</code></a> returns an <a href="enum.UpdateAction.html"><code>UpdateAction</code></a> describing one of three
outcomes: either, <a href="enum.UpdateAction.html#variant.None"><code>None</code></a>, meaning nothing significant changed as a result
of the message and we don't need to update the UI, or <a href="enum.UpdateAction.html#variant.Render"><code>Render</code></a>, meaning
you made a change which should be reflected in the UI, causing the framework to call your
<a href="trait.Component.html#tymethod.view"><code>view</code></a> method and re-render the UI. Finally, you can also return
<a href="enum.UpdateAction.html#variant.Defer"><code>Defer</code></a> with a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> in case you need to
do some I/O or a similar asynchronous task - the <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> should resolve to a
<a href="trait.Component.html#associatedtype.Message"><code>Component::Message</code></a> which will be passed along to <a href="trait.Component.html#method.update"><code>update</code></a>
when the <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> resolves.</p>
<h2 id="signal-handlers" class="section-header"><a href="#signal-handlers">Signal Handlers</a></h2>
<p>Other than <a href="enum.UpdateAction.html#variant.Defer"><code>UpdateAction::Defer</code></a>, where do these messages come from?
Usually, they will be triggered by user interaction with the UI. Using the <a href="macro.gtk.html"><code>gtk!</code></a>
macro, you can attach signal handlers to
<a href="https://developer.gnome.org/gobject/stable/howto-signals.html">GTK signals</a>
which respond to a signal by sending a message to the current component.</p>
<p>For instance, a GTK <a href="../gtk/struct.Button.html"><code>Button</code></a> has a <a href="../gtk/trait.ButtonExt.html#tymethod.connect_clicked"><code>clicked</code></a> signal which is
triggered when the user clicks on the button, as the name suggests. Looking at the
<a href="../gtk/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a> method, we see that it takes a single <code>&amp;Self</code> argument,
representing the button being clicked. In order to listen to this signal, we attach a closure
with a similar function signature to the button using the <code>on</code> syntax. The closure always takes the
same arguments as the <code>connect_*</code> callback, but instead of returning nothing it returns a message of
the component's message type. This message will be passed to the component's
<a href="trait.Component.html#method.update"><code>update</code></a> method by the framework.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">gtk</span><span class="macro">!</span> {
    <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Click me&quot;</span> <span class="ident">on</span> <span class="ident">clicked</span><span class="op">=</span><span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">Message</span>::<span class="ident">ButtonWasClicked</span> <span class="op">/</span><span class="op">&gt;</span>
}</pre></div>
<p>This will cause a <code>Message::ButtonWasClicked</code> message to be sent to your component's
<a href="trait.Component.html#method.update"><code>update</code></a> function when the user clicks the button.</p>
<p>Signal handlers can also be declared as <code>async</code>, which will cause the framework to wrap the handler
in an <code>async {}</code> block and <code>await</code> the
message result before passing it on to your update function. For instance, this very contrived
example shows a message dialog asking the user to confirm clicking the button before sending the
<code>ButtonWasClicked</code> message.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">gtk</span><span class="macro">!</span> {
    <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Click me&quot;</span> <span class="ident">on</span> <span class="ident">clicked</span><span class="op">=</span><span class="kw">async</span> <span class="op">|</span><span class="kw">_</span><span class="op">|</span> {
        <span class="ident">vgtk</span>::<span class="ident">message_dialog</span>(
            <span class="ident">vgtk</span>::<span class="ident">current_window</span>().<span class="ident">as_ref</span>(),
            <span class="ident">DialogFlags</span>::<span class="ident">MODAL</span>, <span class="ident">MessageType</span>::<span class="ident">Info</span>, <span class="ident">ButtonsType</span>::<span class="prelude-val">Ok</span>, <span class="bool-val">true</span>,
            <span class="string">&quot;Please confirm that you clicked the button.&quot;</span>
        ).<span class="kw">await</span>;
        <span class="ident">Message</span>::<span class="ident">ButtonWasClicked</span>
    } <span class="op">/</span><span class="op">&gt;</span>
}</pre></div>
<h2 id="the-gtk-syntax" class="section-header"><a href="#the-gtk-syntax">The <code>gtk!</code> Syntax</a></h2>
<p>The syntax for the <a href="macro.gtk.html"><code>gtk!</code></a> macro is similar to <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>, but with a number of necessary
extensions.</p>
<p>A GTK widget (or, in fact, any GLib object, but most objects require widget children) can be
constructed using an element tag. Attributes on that tag correspond to <code>get_*</code> and <code>set_*</code> methods
on the GTK widget. Thus, to construct a GTK <a href="../gtk/struct.Button.html"><code>Button</code></a> calling <a href="../gtk/trait.ButtonExt.html#tymethod.set_label"><code>set_label</code></a>
to set its label:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">gtk</span><span class="macro">!</span> {
    <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Click me&quot;</span> <span class="op">/</span><span class="op">&gt;</span>
}</pre></div>
<p>A GTK container is represented by an open/close element tag, with child tags representing its
children.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">gtk</span><span class="macro">!</span> {
    <span class="op">&lt;</span><span class="ident">Box</span> <span class="ident">orientation</span><span class="op">=</span><span class="ident">Orientation</span>::<span class="ident">Horizontal</span><span class="op">&gt;</span>
        <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Left click&quot;</span> <span class="op">/</span><span class="op">&gt;</span>
        <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Right click&quot;</span> <span class="op">/</span><span class="op">&gt;</span>
    <span class="op">&lt;</span><span class="op">/</span><span class="ident">Box</span><span class="op">&gt;</span>
}</pre></div>
<p>If a widget has a constructor that takes arguments, you can use that constructor in place
of the element's tag name. This syntax should only be used in cases where a widget simply cannot be constructed
using properties alone, because the differ isn't able to update arguments that may have changed
in constructors once the widget has been instantiated. It should be reserved only for when it's
absolutely necessary, such as when constructing an <a href="../gtk/struct.Application.html"><code>Application</code></a>, which doesn't
implement <a href="../gtk/struct.Buildable.html"><code>Buildable</code></a> and therefore can't be constructed in any way other than through
a constructor method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">gtk</span><span class="macro">!</span> {
    <span class="op">&lt;</span><span class="ident">Application</span>::<span class="ident">new_unwrap</span>(<span class="prelude-val">None</span>, <span class="ident">ApplicationFlags</span>::<span class="ident">empty</span>()) <span class="op">/</span><span class="op">&gt;</span>
}</pre></div>
<p>Sometimes, a widget has a property which must be set through its parent, such as a child's
<code>expand</code> and <code>fill</code> properties inside a <a href="../gtk/struct.Box.html"><code>Box</code></a>. These properties correspond to
<code>set_child_*</code> and <code>get_child_*</code> methods on the parent, and are represented as attributes
on the child with the parent's type as a namespace, like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">gtk</span><span class="macro">!</span> {
    <span class="op">&lt;</span><span class="ident">Box</span><span class="op">&gt;</span>
        <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Click me&quot;</span> <span class="ident">Box</span>::<span class="ident">expand</span><span class="op">=</span><span class="bool-val">true</span> <span class="ident">Box</span>::<span class="ident">fill</span><span class="op">=</span><span class="bool-val">true</span> <span class="op">/</span><span class="op">&gt;</span>
    <span class="op">&lt;</span><span class="op">/</span><span class="ident">Box</span><span class="op">&gt;</span>
}</pre></div>
<p>The final addition to the attribute syntax pertains to when you need to qualify an
ambiguous method name. For instance, a <a href="../gtk/struct.MenuButton.html"><code>MenuButton</code></a> implements both
<a href="../gtk/trait.WidgetExt.html"><code>WidgetExt</code></a> and <a href="../gtk/trait.MenuButtonExt.html"><code>MenuButtonExt</code></a>, both of which contains
a <code>set_direction</code> method. In order to let the compiler know which one you mean, you
can qualify it with an <code>@</code> and the type name, like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="op">&lt;</span><span class="ident">MenuButton</span> @<span class="ident">MenuButtonExt</span>::<span class="ident">direction</span><span class="op">=</span><span class="ident">ArrowType</span>::<span class="ident">Down</span> <span class="op">/</span><span class="op">&gt;</span>
<span class="op">&lt;</span><span class="ident">MenuButton</span> @<span class="ident">WidgetExt</span>::<span class="ident">direction</span><span class="op">=</span><span class="ident">TextDirection</span>::<span class="ident">Ltr</span> <span class="op">/</span><span class="op">&gt;</span></pre></div>
<h3 id="interpolation" class="section-header"><a href="#interpolation">Interpolation</a></h3>
<p>The <code>gtk!</code> macro's parser tries to be smart about recognising Rust expressions as attribute
values, but it's not perfect. If the parser chokes on some particularly complicated Rust
expression, you can always wrap an attribute's value in a <code>{}</code> block, as per <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>.</p>
<p>This curly bracket syntax is also used to dynamically insert child widgets into a tree.
You can insert a code block in place of a child widget, which should return an iterator
of widgets that will be appended by the macro when rendering the virtual tree.</p>
<p>For instance, to dynamically generate a series of buttons, you can do this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">gtk</span><span class="macro">!</span> {
    <span class="op">&lt;</span><span class="ident">Box</span><span class="op">&gt;</span>
        {
            (<span class="number">1</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">counter</span><span class="op">|</span> {
                <span class="macro">gtk</span><span class="macro">!</span> { <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;Button #{}&quot;</span>, <span class="ident">counter</span>) <span class="op">/</span><span class="op">&gt;</span> }
            })
        }
    <span class="op">&lt;</span><span class="op">/</span><span class="ident">Box</span><span class="op">&gt;</span>
}</pre></div>
<h2 id="subcomponents" class="section-header"><a href="#subcomponents">Subcomponents</a></h2>
<p>Components are designed to be composable, so you can place one component inside
another. The <code>gtk!</code> syntax for that looks like this:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="op">&lt;</span>@<span class="ident">Subcomponent</span> <span class="ident">attribute_1</span><span class="op">=</span><span class="string">&quot;hello&quot;</span> <span class="ident">attribute_2</span><span class="op">=</span><span class="number">1337</span> <span class="op">/</span><span class="op">&gt;</span></pre></div>
<p>The subcomponent name (prefixed by <code>@</code> to distinguish it from a GTK object) maps to
the type of the component, and each attribute maps directly to a property on its
<a href="trait.Component.html#associatedtype.Properties"><code>Component::Properties</code></a> type. When a subcomponent is constructed,
the framework calls its <a href="trait.Component.html#method.create"><code>create</code></a> method with the property object constructed
from its attributes as an argument.</p>
<p>A subcomponent needs to implement <a href="trait.Component.html#method.create"><code>create</code></a> and <a href="trait.Component.html#method.change"><code>change</code></a>
in addition to <a href="trait.Component.html#method.update"><code>update</code></a> and <a href="trait.Component.html#tymethod.view"><code>view</code></a>. The default implementations
of these methods will panic with a message telling you to implement them.</p>
<p>Subcomponents do <em>not</em> support signal handlers, because a component is not a GTK object. You'll have
to use the <a href="struct.Callback.html"><code>Callback</code></a> type to communicate between a subcomponent and its parent.</p>
<p>This is what a very simple button subcomponent might look like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyButton</span> {
    <span class="kw">pub</span> <span class="ident">label</span>: <span class="ident">String</span>,
    <span class="kw">pub</span> <span class="ident">on_clicked</span>: <span class="ident">Callback</span><span class="op">&lt;</span>()<span class="op">&gt;</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">MyButtonMessage</span> {
    <span class="ident">Clicked</span>
}

<span class="kw">impl</span> <span class="ident">Component</span> <span class="kw">for</span> <span class="ident">MyButton</span> {
    <span class="kw">type</span> <span class="ident">Message</span> <span class="op">=</span> <span class="ident">MyButtonMessage</span>;
    <span class="kw">type</span> <span class="ident">Properties</span> <span class="op">=</span> <span class="self">Self</span>;

    <span class="kw">fn</span> <span class="ident">create</span>(<span class="ident">props</span>: <span class="self">Self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
        <span class="ident">props</span>
    }

    <span class="kw">fn</span> <span class="ident">change</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">props</span>: <span class="self">Self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">UpdateAction</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="ident">props</span>;
        <span class="ident">UpdateAction</span>::<span class="ident">Render</span>
    }

    <span class="kw">fn</span> <span class="ident">update</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">msg</span>: <span class="self">Self</span>::<span class="ident">Message</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">UpdateAction</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="ident">msg</span> {
            <span class="ident">MyButtonMessage</span>::<span class="ident">Clicked</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="self">self</span>.<span class="ident">on_clicked</span>.<span class="ident">send</span>(());
            }
        }
        <span class="ident">UpdateAction</span>::<span class="prelude-val">None</span>
    }

    <span class="kw">fn</span> <span class="ident">view</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">VNode</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="macro">gtk</span><span class="macro">!</span> {
            <span class="op">&lt;</span><span class="ident">Button</span> <span class="ident">label</span><span class="op">=</span><span class="self">self</span>.<span class="ident">label</span>.<span class="ident">clone</span>() <span class="ident">on</span> <span class="ident">clicked</span><span class="op">=</span><span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">MyButtonMessage</span>::<span class="ident">Clicked</span> <span class="op">/</span><span class="op">&gt;</span>
        }
    }
}</pre></div>
<p>Note that because this component doesn't have any state other than its properties, we
just make <code>Self::Properties</code> equal to <code>Self</code>, there's no need to keep two identical types
around for this purpose. Note also that the callback passes a value of type <code>()</code>, because
the <code>clicked</code> signal doesn't contain any useful information besides the fact that it's
being sent.</p>
<p>This is how you'd use this subcomponent with a callback inside the <a href="trait.Component.html#tymethod.view"><code>view</code></a>
method of a parent component:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">view</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">VNode</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
    <span class="macro">gtk</span><span class="macro">!</span> {
        <span class="op">&lt;</span><span class="ident">Box</span><span class="op">&gt;</span>
            <span class="op">&lt;</span><span class="ident">Label</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Here is a button:&quot;</span> <span class="op">/</span><span class="op">&gt;</span>
            <span class="op">&lt;</span>@<span class="ident">MyButton</span> <span class="ident">label</span><span class="op">=</span><span class="string">&quot;Click me!&quot;</span> <span class="ident">on</span> <span class="ident">clicked</span><span class="op">=</span><span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">ParentMessage</span>::<span class="ident">ButtonClicked</span> <span class="op">/</span><span class="op">&gt;</span>
        <span class="op">&lt;</span><span class="op">/</span><span class="ident">Box</span><span class="op">&gt;</span>
    }
}</pre></div>
<p>Note that the return type of the <code>on_clicked</code> callback is the message type of the parent
component - when the subcomponent is constructed, the parent component will wire any callback
up to its <a href="trait.Component.html#method.update"><code>update</code></a> function for you automatically with a bit of <code>unsafe</code>
trickery, so that the subcomponent doesn't have to carry the information about what type of
parent component it lives within inside its type signature. It'll just work, with nary a
profunctor in sight.</p>
<h2 id="logging" class="section-header"><a href="#logging">Logging</a></h2>
<p><code>vgtk</code> uses the <a href="https://crates.io/crates/log"><code>log</code></a> crate for debug output. You'll need to provide your own logger for this;
the example projects show how to set up <a href="https://crates.io/crates/pretty_env_logger"><code>pretty_env_logger</code></a> for logging to the
standard output. To enable it, set the <code>RUST_LOG</code> environment variable to <code>debug</code> when running the
examples. You can also use the value <code>vgtk=debug</code> to turn on debug output only for <code>vgtk</code>, if you have
other components using the logging framework. At log level <code>debug</code>, it will log the component messages
received by your components, which can be extremely helpful when trying to track down a bug
in your component's interactions. At log level <code>trace</code>, you'll also get a lot of <code>vgtk</code> internal
information that's likely only useful if you're debugging the framework.</p>
<h2 id="work-in-progress" class="section-header"><a href="#work-in-progress">Work In Progress</a></h2>
<p>While this framework is currently sufficiently usable that we can implement <a href="http://todomvc.com/">TodoMVC</a> in it, there
are likely to be a lot of rough edges still to be uncovered. In particular, a lot of properties on
GTK objects don't map cleanly to <code>get_*</code> and <code>set_*</code> methods in the <a href="https://gtk-rs.org/">Gtk-rs</a> mappings, as required
by the <a href="macro.gtk.html"><code>gtk!</code></a> macro, which has necessitated the collection of hacks in
<a href="ext/index.html"><code>vgtk::ext</code></a>. There are likely many more to be found in widgets as yet unused.</p>
<p>As alluded to previously, the diffing algorithm is also complicated by the irregular structure of the
GTK widget tree. Not all child widgets are added through the <a href="../gtk/struct.Container.html"><code>Container</code></a> API, and while
most of the exceptions are already implemented, there will be more. There's also a lot of room yet
for optimisation in the diffing algorithm itself, which is currently not nearly as clever as the state
of the art in the DOM diffing world.</p>
<p>Not to mention the documentation effort.</p>
<p>In short, <a href="https://github.com/bodil/vgtk/pulls">pull requests</a> are welcome.</p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="ext/index.html" title='vgtk::ext mod'>ext</a></td><td class='docblock-short'><p>Helper traits for adapting the GTK API to the <a href="../macro.gtk.html"><code>gtk!</code></a> macro's mindset.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="lib/index.html" title='vgtk::lib mod'>lib</a></td><td class='docblock-short'><p>Re-exports of GTK and its associated libraries.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="types/index.html" title='vgtk::types mod'>types</a></td><td class='docblock-short'><p>Useful types for GTK extensions.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.gtk.html" title='vgtk::gtk macro'>gtk</a></td><td class='docblock-short'><p>Generate a virtual component tree.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.gtk_if.html" title='vgtk::gtk_if macro'>gtk_if</a></td><td class='docblock-short'><p>Generate a virtual component tree only if a condition is true.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.on_signal.html" title='vgtk::on_signal macro'>on_signal</a></td><td class='docblock-short'><p>Connect a GLib signal to a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.stream_signal.html" title='vgtk::stream_signal macro'>stream_signal</a></td><td class='docblock-short'><p>Connect a GLib signal to a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Callback.html" title='vgtk::Callback struct'>Callback</a></td><td class='docblock-short'><p>A callback property for sub-<a href="trait.Component.html"><code>Component</code></a>s.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.MenuBuilder.html" title='vgtk::MenuBuilder struct'>MenuBuilder</a></td><td class='docblock-short'><p>Makes a <a href="https://gtk-rs.org/docs/gtk/struct.Menu.html"><code>gtk::Menu</code></a> for you.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Scope.html" title='vgtk::Scope struct'>Scope</a></td><td class='docblock-short'><p>A channel for sending messages to a <a href="trait.Component.html"><code>Component</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.VNodeIterator.html" title='vgtk::VNodeIterator struct'>VNodeIterator</a></td><td class='docblock-short'><p>An iterator over zero or one <a href="enum.VNode.html"><code>VNode</code></a>s.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.UpdateAction.html" title='vgtk::UpdateAction enum'>UpdateAction</a></td><td class='docblock-short'><p>An action resulting from a <a href="trait.Component.html#method.update"><code>Component::update()</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.VNode.html" title='vgtk::VNode enum'>VNode</a></td><td class='docblock-short'><p>A node in the virtual component tree representing a <a href="trait.Component.html"><code>Component</code></a> or a Gtk widget.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Component.html" title='vgtk::Component trait'>Component</a></td><td class='docblock-short'><p>This is the trait your UI components should implement.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.current_object.html" title='vgtk::current_object fn'>current_object</a></td><td class='docblock-short'><p>Get the current <a href="../glib/object/struct.Object.html"><code>Object</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.current_window.html" title='vgtk::current_window fn'>current_window</a></td><td class='docblock-short'><p>Get the current <a href="../gtk/struct.Window.html"><code>Window</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.menu.html" title='vgtk::menu fn'>menu</a></td><td class='docblock-short'><p>Construct a <a href="struct.MenuBuilder.html"><code>MenuBuilder</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.message_dialog.html" title='vgtk::message_dialog fn'>message_dialog</a></td><td class='docblock-short'><p>Open a simple <a href="../gtk/struct.MessageDialog.html"><code>MessageDialog</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.quit.html" title='vgtk::quit fn'>quit</a></td><td class='docblock-short'><p>Tell the running <a href="../gtk/struct.Application.html"><code>Application</code></a> to quit.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.run.html" title='vgtk::run fn'>run</a></td><td class='docblock-short'><p>Run an <a href="../gtk/struct.Application.html"><code>Application</code></a> component until termination.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.run_dialog.html" title='vgtk::run_dialog fn'>run_dialog</a></td><td class='docblock-short'><p>Launch a <a href="../gtk/struct.Dialog.html"><code>Dialog</code></a> component as a modal dialog.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.start.html" title='vgtk::start fn'>start</a></td><td class='docblock-short'><p>Start an <a href="../gtk/struct.Application.html"><code>Application</code></a> component.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "vgtk";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>